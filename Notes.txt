Firstly we are gonna create a virtual environment to separate all our installs from our global machine (It is a good practice to do this) in a specifies folder.

For this, firstly install the virtual environment at the preffered location using
          pip install virtualenv

Now we will run this command and name our environment whatever we want (eg, env)
          virtualenv env
And this will now create our virtual environment.

Now we are going to activate the environment.
          env/scripts/activate
Or 
          env/Scripts/activate
As we have activated our environment, we are now in the virtual environment instead of our global machine.
To deactivate,
          env/scripts/deactivate
If it is not working, try to run just 'deactivate'

Whenever you log into this, you have to activate the environment.

As we are in the environment, we are now installing the required packages.
          pip install django

We have installed Django now and now we have the access to all the commands.

Now we are gonna start our project with whatever name we want
         django-admin startproject myproject
This command is start a django project named 'myproject' and gonna create boiler plate to setup our application.

Now we are gonna change our directory to the project directory.
          cd myproject

Now we will start the django development server
         python manage.py runserver

Everyone likes to store their environment in a different way, so what I am gonna do is, I am gonna move my env to myproject folder.

Now we are gonna open our IDE, open terminal and run our server again.

Now we can take a look at the python files inside the project folder.
         wsgi.py     -> Web Server Gateaway Interface
         urls.py     -> It gives a list of all the configured paths like admin, home, about etc.
         asgi.py     -> Asynchronous Server Gateway Interface
         settings.py -> This is where we have all our core project configurations. This is like command center of our project.

Now are gonna work on rendering something out and changing that default template that we saw.
In Django, we are gonna be  working with something called as Apps here. There are apps that handle different parts of our application.
Basically apps are little components of our website that handles different parts of a website.

-----

In order to create our first app here.
We are gonna open a new tab on the terminal and our server is running sideways.

Now we will hit a command
          python manage.py startapp base
This is now gonna create an app named base (like baseapp) and now a folder is create named base.

So at this point, the django project doesn't know about the base app that we have just created, so we have to connect this.

In this base folder, we have a file views.py, this is basically what happens when somenone goes to a specific url. These are gonna be functions or classes and these are gonna fire off the things like any kind of queries to the database, any template that we need to render.
And next we have our models.py file where we have configured the database.
And more files like admin panel and core app configurations

So now we will head back to the main project (i.e, myproject) and let this project know that we have created a new app.
So in myproject -> settings.py -> installed apps. what we could do is just add base like 'base' and it will know about this folder or we can give the direct file path to configure it to the app. (i.e, 'base.apps.BaseConfig').
So now django knows about out app.

Let's talk about url routing and our views. So typically all our views will be handled from the views.py from the base folder.

urls.py is our main url file.
We can have multiple url files but we will have only two i.e, one the root url and another one for our specific app.

So for that we will create a function named home which is gonna take request obejct as an argument. Request object is gonna be the http object. This is gonna tell us what kind of data is being passed in etc.
Now we are gonna import the http module and just return the http response.

Now we will go into the urls and the specify the url path and the homepage is going to be the root domain (empty string ('') reprents the core url). and we can create other url's similarly. 

# Urls trigger views and that is what users get as an http response. (home, about and room are views).
So this is not a good practice, if we create a big project, it will be really messy because is goona be a lot of logic in the views and lot of functionality.
and this is why django creates apps for us and they give us a structure to separate all of our code.

So we are gonna copy our views from here and paste these views into the views.py of our app. 
Now our urls.py file doesn't know how to call those views. So what we are gonna do is we will create an urls.py file into our app to handle all the routing for this app.

Firstly we are gonna import a path function and then the views of that app.
Now we need a list called 'url patterns' and specify all the url paths that a user can go to.
Now we will call path function for all our views and we can give them names also to reference a specific view or url by it's name.
So now we have two views and two urls for these views in our app.

But till now django doesn't know about these urls and views. So we will now add the include package to the main urls file and add a path to urls of our app using the include function. 

Now the urls file of our app is gonna handle all the routing.
So now the default django template is removed.

--- 

We have simple http responses, these aren't dynamic, we cannot add our own html to that. There is a way but it is gonna be too messy.

So now let's add templates and for that we are creating a folder for storing all our templates and there are few ways to configure these.

Lets create a file named home.html in the templates folder.
So now we can add markups instead of simple response.
Now we need to return these inside of our views.

First thing we are gonna do is let django know about this template folder.
For that we have to go to the Templates list of our settings.py file in our main folder. In there we have a list called 'dirs' and add our templates folder using the BASE_DIR variable (This variable acutally sets our path to the base directory which here means go to the base directory and there the template folder is).

In order to reference these templates, we need to go to the views. Now we can get rid of the Http response and use render() in place of that and it takes two parameters. First one is the request object and the next one is the template name
(Remove the imported Http packge as it is not needed now.)

Now, just rendering the template isn't the best thing if we are may be adding a navigation bar. Imagine coding the navigation bar in the every single template adding all the tags and the styling.
So here we are gonna use the template inheritance and we can also include section of templates inside of other templates.
So we are gonna create a file just to contain the navbar and create an a tag inside of that and this is gonna be a link to the homepage like a logo such that whenever we click on the logo, we will be sent to the home page.

So now this code should be seen on every single page. So we have to go to the home.html file and add a template tag like ' {% include 'navbar.html' %} '. 

Now what we could do is we could create a main.html file and this is gonna allow us to create a wrapper around our templates. By default our will have different styles, themes. So we want  to include one style tag into our main theme of our website and we want it to simply encapsulate all the templates in our project.

Now get the html boiler plate and in the body section we have to add tempalates. So it is gonna tell our website where to add all these child templates when we wrap another template in our website.
Create a block for content. So in our homepage we have our main page and all the homepage content will be in here.

So instead of adding the navbar file in every template, we can now just add this in our main.html file. 
Now we have our main.html file and now we are gonna extend this in our home.html file like ' {% extends 'main.html' %} '.
Now in order to see our home content, we can now add these content tags in our home.html to let that know where our content is and now not much is gonna change we are still gonna see our navigation bar but it is no longer present in our home.html file.
Now extend main.html to room.html also wrap it with content files as we have done in the home.html file.

So that is all about including and extending the main template. Now let's pass in some data into our templates.

Let's go to views.py and create a variable named rooms which is gonna be a python list and we are gonna have some rooms which are dictionaries and represented like objects. Each room will have an id and name of that room.
Now as we have created the list, we want to render this out in our home.html template. At this point what we could do is we can pass this rooms list as a parameter in the home view as a dictionary which means it has a key value pair, like this :
                             {'rooms': rooms}   where the key specifies how we want to address this in the template and value specifies what we are passing in, which is the rooms list here.
Now we have the access of the rooms list in our template. So now we have to go to the home.html and render this list out.

OR we can save this in a variable and pass that variable just like,
             context = {'rooms': rooms}

So in that, let's create a div for the main page and inside of that create a div again which renders out all the items here. In there create a for loop using the template just like,
                      {% for room in rooms %}

                      {% endfor %}
So the difference between regular python and this templating engine is that, we have to close our room insted of just writing the syntax. So we have to close our for loop and if statements.
In each iteration we have to pass an h5 tag so we have to create a div for that.
We want to print like,  1 -- Let's learn python, for all the id's.

We know that variables can be passed in with two curly braces. So we will do like, 
                      {{room.id}} -- {{room.name}} 
So we are accessing the key value pairs from the dictionary using the object of that list.

In the views.py, we can also use the if else statements. For eg, the age, If the age is less than this, render this, otherwise render this.

-----

So we created templates folder to store all the templates we are gonna be using in our app. In the future, we will have different apps which handles different parts of our website. So we can create a templates folder which will be specific to our app.
So create a templates folder inside our base app and the weird thing about this is that django requires us to create another folder inside our templates folder which have to be named whatever your app's name is ( in our case base).
Now we have to shift our home and room files here because these are specific to our app.
So in order to actually work with this new template, we just have to specify our app now in the views.py just like,
                                 'base/home.html'           which was previously like      'home.html'
Do the same for room also.
So now all our apps templates are in the apps directory and our main templates are in the root folder.

Dynamic URL routing
So how do we get a specific object of a single room here. (eg, Click on a room and see the info about that)
So room does not have any way of that.
So the way we are gonna do this is by changing the urls.py.
We can pass a dynamic value for that (use angluar brackets <>). In that we are goona pass a string str and any value name pk for primary key.
                                    'room/<str:pk>/'
This str could be an int or slug etc based on what you are passing.

So we have to pass this pk as a parameter in the room method of the views.py.
So now we have access to whatever is inside of that parameter.

Now we are gonna wrap the room.name in the home.html file with the a tags to make them clickable and the href will be "/room/{{room.id}}" to show the details of room name as per the room id.
To actually get the value of the id, later on we are gonna use the pk to create the database but now we are using the list 
Now write the logic in the room method,
  Firstly we are gonna set the room to none and we are gonna loop through the rooms value. So whatever id matched to the pk, set that to room then we can set a context dictionary and set that context as the third parameter.
               room = none
               for i in rooms:
                   if i['id'] == int(pk):
                       room = i
               context = {'room': room}

So now in the room template we can just pass in the value. We can change that to
                 {{ room.name}}

So now whenever we click on the a tag that we have created, it will redirect it according to the id and show the name of the room there.

Now let's see how to get dynamic values from our templates
So in the url's there is a reason why we have given names to that, let's say at some point we want to change the url path, So we have to do is we have to go to every single tempate or wherever we are using it and then update all these values. It can be very annoying. So what we can do is we can change the value to whatever we want, but we can still access this url by its name
Let's go into home.html and instead to writing the path in the href we can change it with the url tag which is the built in tag inside the django templating engine just like
                 " {% url 'room' room.id %} "       inside the quotes there is the url name and the room.id is the dynamic value 
It will create the url like /room/2/,  where 2 is the room id.

So now if we want to change the url path, we do not want to change it everywhere. So it is much faster than that.

----------------

Now we are gonna set up the real database which is gonna be in our sqlite database and we want to actually query data from the database. So there will not be any need of using the rooms list anymore.

In the terminal we can see 18 unapplied migrations. Inside our settings.py, we have different apps and a lot of these apps have database sections. So basically we have a database prepped so we have a couple of tables which are ready to be migrated like django builds out a user table for us, for authentication they have built a table to store session ids. So django creates these migrations and these are basically sql commands and are ready to be executed. So they are ready to be activated but are not triggered yet. Once I run these migrations, these commands are gonna be activated and these are gonna build out all these tables which are inside the apps list (i.e, sessions, admin etc.) So we do not even have to configure the tables, django is really good at setting these up for us and making this easy. Now we are still gonna create our tables but these are the default ones that django gives us.

So stop the server and run 'python manage.py migrate'. Now these migrations are applied and basically that built out the database for us.
Now if we run our server again we are not gonna see the unapplied migations.

Now go to our app that is base and open the models.py file. This is the file where we are gonna create our database tables. 
So what we are gonna do in here is, we are gonna create python classes. The class that we are gonna create is gonna represent the database tables. The name of the table is represented by the name of the class and every single attribute in the class is gonna represent the column. So every single time we create a new row in the table, that is going to be the instance of the class.
              Class Name -> Table Name
              Attributes -> Column Name
This is called a model of a table that is why they are called models.

So the first table that we are gonna create is the table for the room which is like,
             class Room(models.Model):
                 name = models.CharField(max_length = 200)
                 description = models.TextField(null = True, blank = True)
                 updated = models.DateTimeField(auto_now = True)
                 created = models.DateTimeField(auto_now_add = True)

Models by default have an id generated which starts with 1. We can also specify the id if we want.

CharField has max_length of 255 characters while TextField can hold more than 255 characters. Use TextField when you have a large string as input.
By default, the null is set to false but here we set it to true because if it is false this means that the database cannot have an instance of this model here without having something in it. So it can be blank. So we set null to true which means that it can be blank and the next parameter is the blank which means that whenever we run the save method like we submit a forum that form can be empty.
                 blank -> For the save in the forms.
                 null -> For database.
This means that description can be left empty but name cannot because null is false by default.
Updated is gonna take a snapshot anytime this instance was updated. auto_now is set to true which means that every time the save method is called go ahead and save the timestamp automatically.

auto_now saves the timestamp everytime we save and auto_now_add only saves once when when that is first created.

We have also created a self representation of this

So the first thing after creating a model to the database is the migration. So what it is gonna do essentially is it is gonna craete a file which have a list of sql commands and how to execute this and add it to the database.

We have already executed the built-in migrations, now we are gonna execute this new migration like
             python manage.py makemigrations
So now we can see a new file in the migrations folder of the base app.
So once we make a migration and we can make a new miigration using the migrate command and this will go into the latest migration and it will execute those and we can see these migrations being applied.
Now this table is included to the database.

Let's say we want to view this, because we are not adding any third party packages to work with our sqlite database, we are gonna use the built in django admin panel with the /admin url.
In the admin panel, django already has a built-in authentication for us and in order to log in, we need a user and this user need to have admin level permission.

So we can generate the user from the command panel. For this, run
             python manage.py createsuperuser
and it will ask for the username, email and passwork for the superuser that we are creating.


So now this user is added to the database
Now if I log in to the panel, I can actually work with the database

We added in the room table here but we cannot see it in the panel. To actually see this, we need to go to the admin.py in our base app first import the room model like
         from .models import Room
Now we have to register this model with the admin panel. By this we are actually saying to the admin panel that we want to view and work with item into the built-in admin panel. For this, we have to do,
        admin.site.register(Room)

Now we can see the Room into the admin panel.
We can add rooms from there also. Now I have added two items inside of that room table. Now as we have added these we can work with the CRUD operations, render this out inside out list and view the  details.
We have added the rooms to the database but now we want to see this on the page.
In the views.py file  firstly we will import the model that we want to query (i.e, Room here)

There is something called as MODEL MANAGER.
This is how we can make queries to the database. 
            
             queryset = ModelName.objects.all()                    where, queryset = Variable that holds response
                                                                          objects  = Model objects attribute
                                                                          all      = method  ( some other methods are .get(), .filter(), .exclude() ) 
                                                                          ModelName is the name of the model which is in our case Room

So in the home method write, 
      rooms = Room.objects.all()
This is gonna give us all the rooms in the database. This rooms will now override the rooms list that we had created.
Now this room will be passed to the database.

Now if I refresh in the browser I can see the items from the database not from the rooms list that we had created before because the list is now overridden.
NOw if I click on these, it is still gonna work because our id is same as the default model ids.

We can comment out the rooms list because it is now not needed.

Now in the room method, we can now get rid of all the loops and get the room from the room model. So we are doing
           room = Room.objects.get()

get() is gonna return one single item. We need to get this by one unique value because lets say we have two items with the same names, it is gonna throw an error because it needs to get a single objects. So we have entered by the id because id should be unique in the database.

So now whenever we click on the links on the page, it goes to the view , queries the database and gets back that single item and then it renders that.

At this point we want to add a few more models to the database. We have rooms here but each room should have a category. So we want to bring that in.

Each Room is gonna have a message so we are creating a message model and for the values for an actual message, First we want to specify a user (user that is sending the message) then we are gonna specify a room which is going to be a one to many relationship because one user can have many rooms.

In there we will do models.ForeignKey() and as an argument we are gonna give the parent which is Room and the second argument is gonna be the on_delete.
If on_delete is set to models.SET_NULL it means that, whenever the parent is deleted all the instance will be set to null but the msg will still stay in the database or if we set it to models.CASCADE it means that we are simply gonna delete all the msg in that room whenever the parent is deleted.
           room = models.ForeignKey(Room, on_delete= models.SET_NULL)

For the actual msg we are gonna set a variable named 'body' and just copy and paste updated and deleted from the Room
           body = models.TextField()                 we kept it empty because we want user to write a msg.

For the user variable django already builds in  a user model for us. So for now we are gonna start with the default user model. 
For this we are gonna import the User model and now let's set the relationship and in this case this is gonna be a one to many relationship (user can have many message but a message will only have one user) and for that we will do
         user = models.ForeignKey(User, on_delete = models.CASCADE)

Now we have to go to up of the Room and in this case the Room is gonna be a child of the Topic, we have to specify a class above it. And in that we are gonna add one attribute only which is name attribute which is going to be a character field and we are gonna specify the max_length for it and a self function returning the name.
Now we wanna specify the relationship with the room. A topic can have multiple rooms but a room will only have one topic.
So in the Room attribute, we are gonna specify a topic attribute and we are gonna connect it using to the Topic using the models.ForeignKey() like,
        Topic = models.ForeignKey(Topic, on_delete = models.SET_NULL)
Because the Topic model is placed above the Room in the code, if I shift it below, I can still access this value but now I have to wrap the Topic in a string like 
        Topic = models.ForeignKey('Topic', on_delete = models.SET_NULL)

After setting it null, it will give an issue, which says that we have to allow it to be null because when it gets removed and set to null, we need to make sure that the database will allow it.
        Topic = models.ForeignKey(Topic, on_delete = models.SET_NULL, null=True)

Now we have to create a host attribute in the Room model and set USER as the host like
        Topic = models.ForeignKey(User, on_delete = models.SET_NULL, null=True)

Now we have a relationship to our Host and the User

Now again we have to prep the migrations using 'makemigrations' command in a new terminal and a second migrations file will be created into the migrations folder and then we have to execute them using the 'migrate' command and now that is gonna add it to the database.

Now in the admin.py file, we have to register these models just like we did earlier.

[ 
  NOTE : I got an error for column not found but no error in the tutorial, tried to google it and found the solution which is
                 python manage.py migrate --run-syncdb
       This command is gonna sync the db without the migrations and now the error is gone. 
]

Now we can see the topics and rooms in the admin panel.
Let's add some topics.
Now as we have created the topics, we can now set these topics in our rooms and the host also.
Add one more user and write some messages.

As per the design, we want to render out the username and the topic, so we have to update the templates.

So in the home.html, in the div, add a span tag and to render the username, we can query the host object and render the username from that.
       <span>@{{room.host.username}}</span>
This will render out the username of the host from the database.
Later on, we will make this username clickable.

And we can also render the topic name and for that we are using the small tag.
       <small>{{room.topic.name}}</small>

Now we are done with rendering out the items.

---------------------------

Now we will take a look at the CRUD operations.

So we wanna learn how to work with a database outside of django admin panel. So in order to do this, the first thing I am gonna do is, in the app's template folder I am gonna add a form template for the room and this is gonna update and create a room. So one template for two different views.

So the first thing we are gonna do is extend the main template.
           {% extends 'main.html' %}
and we are gonna wrap all the content

In the block, create a div and in that create a form which has a method POST for creating and updating and there will be an action but if there is no action it is gonna send it to the current URL that we are at. So I can send it to a specific URL.
Inside of every form in the django, for using this template engine we need to add a csrf_token (CSRF = Cross site request forgery). This token will be sent on every form submission. So when we are sending POST request in django, we need to pass in this token with every request just to make sure that there is no malicious attempts. This will help us from cross site forgery attacks.

We want a submit button also, so we are gonna specify that.
         <div>
            <form method = "POST" action="">
        	    {% csrf_token %}

                <input type="submit" value="Submit" />
 
            </form>
          </div>
Now we have our form, we can go to views file and create a view for this.

Creating a view for creting room and adding a URL for the same.
        def createRoom(request):
    		context = {}
    		return render(request, 'base/room_form.html', context)

OK so now we have out URl, a view which renders out a template and now let's just go and link this up.

So we want that user can create a room from the homepage so let's go ahead to that.
Before all the room let's create a link to create the room

We can create this form manually but we are using something called as model form for that (There is definitely a level of abstraction to this).

So let's go ahead and build out a model form. So a model form is a class based representation of a form.
So we are gonna create a new file inside of our base app called as forms.py and inside of this import the ModelForm

So all we do to create a modelform is we create a class. So there are two minimum values that we need here, so when we specify the metadata, we specify the model for which we want to create a form for, which is gonna be room model and we have to specify the field (this is gonna create the form based on the data/ metadata of the room model. we specified all here which means that it is gonna give us all the fields but later on we will specify the specific values that we want in a list)

		class RoomForm(ModelForm):
    			class Meta:
        			model = Room
        			fields = '__all__'


Now inside of the view, import that form and inside of CreateRoom, we are just gonna do
             form = RoomForm()
and now we can pass this in the context
             context = {'form':form}

And now we can pass this in room_form.html like
            {{form}}

Now if we refresh in the browser, we got the form.
Now we are gonna work on this and make it look a little bit better.
But for now we are using a quick shortcut which is {{form.as_p}}. It will wrap a paragraph tag around every input field that the form has.

Now we need to process this data.
To print the submitted data on the console, go to views.py file and below form just write, 
         if request.method == POST:
             print(request.POST)
It will print the data as a dictionary on the console.

We can also process this data manually like
            request.POST.get('name')        --> It will print the name.
But in our case we have the modelform which takes care of all this logic for us.
So we can do it like, 
           form = RoomForm(request.POST)            which means passing all the POST data into the form.
Then to save the form firstly we have to check if all the entries are valid or not. 
          if form.is_valid():
              form.save()
This is gonna save that model in the database.
Once this is save, we want user to be redirected to the homepage again.
So we will import a value called redirect and then below the save, we will return to home.
Now if I click on create room and submit that, we will be redirected to homepage and it will be shown as a new room on the homepage.

The next thing I wanna do is I want newer items to be rendered first.

So for this, we will go to models first and we will directly add this to the room method here. We will create a meta class and specify the ordering there and this is gonna be a list. So we will order this by created and then by updated.
              class Meta:
                   ordering = ['-updated', '-created']
If we don't write - with these, it will order it in the ascending order which means newest one will be last but writing - will invert it and now the newest one will be written last.

now let's go into updating a room. 
To update we already have a template that submits that POST form or the POST request ( in the room_form.html)

Now we need to create a new view and we are gonna call this updateRoom(). It is gonna look a lot like the createRoom() but there are a few changes. As an argument, we are passing the request but this time we are passing the primary key (pk) also with it because we want to know which item to be updated.

Firstly we are gonna get the item which is to be updated (in this case room).
              room = Room.objects.get(id=pk)
So we got the room, now we want the form same as the createRoom() but the difference is when we click to edit a room we want to actually know what room we are gonna edit.
So form = RoomForm() will give us an empty form that we can render in the context dictionary. So how do we get that data prefilled, so we can use the instance and pass in the room.
So now this form will be prefilled with this room value.

So for this we are gonna add an edit buttton on the homepage.

For this, we need a URL and we want id also, so we are adding the primary key also.
         path('update-room/<str:pk>/', views.updateRoom, name = "update-room"),

Now go the home.html page and add in an edit button in the top of the div. 
         <a href="{% url 'update-room' room.id %}">Edit</a>

Now we can see the edit button and when we click on the button, we can see the info. prefilled and we can now edit that from there but if we try to save that we can't because we need to process that info.

We can see that info. but now we need to process this. So we will now specify the method as we have specified before.
         if request.method == 'POST':
              form =  RoomForm(request.POST, instance=room)
              if form.is_valid():
                  form.save()
                  return redirect('home')

this instance parameter is used to tell it which room to edit. If we don't specify this, it is just gonna add a new room instead of updating.

We are done with this, now we gonna add delete method.
We are creating a new method inside of our tempates/base folder just to handle deleting (delete.html). This is gonna be a dynamic template meaning that it will be used for every deleting process when we add more functionalities later.
We are gonna make it pretty generic. 
In this, we will also give a confirmation msg to the user to confirm the deleting process and we are gonna add an obj template which changes which means that object can be msg, comment etc. Then we will add an input button to submit and the value will be confirm and we can also add a button for going back and in this case we want to send user back to the previour page not any specific page and for this href will be.
           href = "{{request.META.HTTP_REFERER}}"            --> This is gonna send the user to where they came from.

Now we have created the tempalate, we can now add the view.
and as a context we will pass the obj which means that room will be called as the obj in the template. In this, we will obviously not save as we were doing previously, we will simply use delete() to delete the room from the database.

Now we have defined the delete functionality also.

We are done with CRUD.

We we want to build some search functionality and add a side bar for quick search also.

Now firstly we are gonna add some styling here and it is gonna be very serious.
Now we will go the home.html and firstly we will make sure that the entire page is wrapped in a div and we are give this div a class called home-container. Inside of this div we will create another div for the side bar which says browse topics (h3 tag).
Now we will create another div and wrap all the rooms in that.

Now we have one container around everything, one for the topics and another one for the list of rooms.

If we refresh it now, we can see that they all are in line, so now we have to create a layout for them.

Now we will go ahead and add some styling right here.
          <style>
              .home-container{
        		display: grid;
        		grid-template-columns: 1fr 3fr;                   This means that there will be two columns as we have 2 col and right one will be wider.
    		  }
	    </style>

After refreshing, we can see two columns now.
Now we want to list out all the topics in the browse topics column.

For this, we will go to the views and make a quick query about the topics and for that we have to import the topics first.
For now, we are gonna list out everything but if we add thousands of topics into our website, we have to filter them out may be. 
           topics = Topic.objects.all()
We will now throw this into the context dictionary.
           'topics':topics
Now we have all out topics and we want to render them out into the home page.
For this, we have to loop through all the topics. In the href, we will send the user back to the homepage and then we will pass in the query.
So what's gonna happen here is we are going the home page when we click in the side bar. So when we click it, it is gonna send the user to the home page and then we will thorow in the topic name.
           {% for topic in topics %}
              <div>
                  <a href="{% url 'home'%}?q={{topic.name}}">{{topic.name}}</a>
              </div>
	      {% endfor %}

Now if we click on that, it is gonna added to the parameter and we can now get this value inside of the view and filter down some data using that.
Now as we have that, we wanna make sure that we can also go to all the topics. For this we are creating another div.
		<div>
               <a href="{% url 'home' %}">All Topics</a>
            </div>

Now in the view for the actual functionality, we can use the filter() method instead of all() but if we do not pass any parameter in the filter(), it is gonna work same as the all().
Now we will create a variable to get the q (q is query which we have just done in the for loop), q is gonna be whatever we pass in the URL. 
So as a parameter, what we can do is, we can go to topics ( models -> topic)  and then I can query upwards to the parent using the __. 
        q = request.GET.get('q')
        rooms = Room.objects.filter(topic__name = q)

Now on the first search, we will have an issue, which is because we do not have any parameters in the URL on the first search. But if we click on the topics, it will do the work.

To solve this, we need to create some kind of condition here. So the first thing is, we are gonna use an inline if statement and we will check if the request method has something and instead of setting the value directly in the parameter, we are gonna use the 'icontains', which means that, our parameter is gonna work only if we have something in the q, otherwise it will work as all().
So this means that, if we do not have anything in the URL, filter() will not work and it will now act as all().

Now if I want to query for the javascript topic but in the query, i only write the jav not the full javascript, it will still work.

Now we do not want user to search from the query in the URL that's why we will add the search bar.
We want the search bar to be dynamic because we are giving the functionality that user can search for the topic, writer etc.

So in the navbar, we can create a form for the GET method
         <form method = "GET" action="{% url 'home' %}">
             <input type="text" name="q" placeholder="Search Rooms">
         </form>

We are specifying the name as q because we want it to take the room and push it into the URL.

Let's see how we can make this dynamic. By now, we are searching by the room name only
For this, in the filter method,  we need to add the parameters but for that we need AND or OR operations to be applied. For that django gives us the qlookup method which gives us the functionaloty to use all these AND or OR operations
               rooms = Room.objects.filter(
        		Q(topic__name__icontains = q) |
        		Q(name__icontains = q) |
        		Q(description__icontains = q)
    		   )
Now we can search using three parameters but firstly we have to import qlookup which can be imported by the name Q
       from django.db.models import Q

Now we want to show the total no. of rooms found. So in the home.html we will just add
          <h5>{{room_count}} rooms available</h5>
Now we have to add this in the view
         room_count = room.count()


Now we want to talk about the authentication.