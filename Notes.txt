Firstly we are gonna create a virtual environment to separate all our installs from our global machine (It is a good practice to do this) in a specifies folder.

For this, firstly install the virtual environment at the preffered location using
          pip install virtualenv

Now we will run this command and name our environment whatever we want (eg, env)
          virtualenv env
And this will now create our virtual environment.

Now we are going to activate the environment.
          env/scripts/activate
Or 
          env/Scripts/activate
As we have activated our environment, we are now in the virtual environment instead of our global machine.
To deactivate,
          env/scripts/deactivate
If it is not working, try to run just 'deactivate'

Whenever you log into this, you have to activate the environment.

As we are in the environment, we are now installing the required packages.
          pip install django

We have installed Django now and now we have the access to all the commands.

Now we are gonna start our project with whatever name we want
         django-admin startproject myproject
This command is start a django project named 'myproject' and gonna create boiler plate to setup our application.

Now we are gonna change our directory to the project directory.
          cd myproject

Now we will start the django development server
         python manage.py runserver

Everyone likes to store their environment in a different way, so what I am gonna do is, I am gonna move my env to myproject folder.

Now we are gonna open our IDE, open terminal and run our server again.

Now we can take a look at the python files inside the project folder.
         wsgi.py     -> Web Server Gateaway Interface
         urls.py     -> It gives a list of all the configured paths like admin, home, about etc.
         asgi.py     -> Asynchronous Server Gateway Interface
         settings.py -> This is where we have all our core project configurations. This is like command center of our project.

Now are gonna work on rendering something out and changing that default template that we saw.
In Django, we are gonna be  working with something called as Apps here. There are apps that handle different parts of our application.
Basically apps are little components of our website that handles different parts of a website.

-----

In order to create our first app here.
We are gonna open a new tab on the terminal and our server is running sideways.

Now we will hit a command
          python manage.py startapp base
This is now gonna create an app named base (like baseapp) and now a folder is create named base.

So at this point, the django project doesn't know about the base app that we have just created, so we have to connect this.

In this base folder, we have a file views.py, this is basically what happens when somenone goes to a specific url. These are gonna be functions or classes and these are gonna fire off the things like any kind of queries to the database, any template that we need to render.
And next we have our models.py file where we have configured the database.
And more files like admin panel and core app configurations

So now we will head back to the main project (i.e, myproject) and let this project know that we have created a new app.
So in myproject -> settings.py -> installed apps. what we could do is just add base like 'base' and it will know about this folder or we can give the direct file path to configure it to the app. (i.e, 'base.apps.BaseConfig').
So now django knows about out app.

Let's talk about url routing and our views. So typically all our views will be handled from the views.py from the base folder.

urls.py is our main url file.
We can have multiple url files but we will have only two i.e, one the root url and another one for our specific app.

So for that we will create a function named home which is gonna take request obejct as an argument. Request object is gonna be the http object. This is gonna tell us what kind of data is being passed in etc.
Now we are gonna import the http module and just return the http response.

Now we will go into the urls and the specify the url path and the homepage is going to be the root domain (empty string ('') reprents the core url). and we can create other url's similarly. 

# Urls trigger views and that is what users get as an http response. (home, about and room are views).
So this is not a good practice, if we create a big project, it will be really messy because is goona be a lot of logic in the views and lot of functionality.
and this is why django creates apps for us and they give us a structure to separate all of our code.

So we are gonna copy our views from here and paste these views into the views.py of our app. 
Now our urls.py file doesn't know how to call those views. So what we are gonna do is we will create an urls.py file into our app to handle all the routing for this app.

Firstly we are gonna import a path function and then the views of that app.
Now we need a list called 'url patterns' and specify all the url paths that a user can go to.
Now we will call path function for all our views and we can give them names also to reference a specific view or url by it's name.
So now we have two views and two urls for these views in our app.

But till now django doesn't know about these urls and views. So we will now add the include package to the main urls file and add a path to urls of our app using the include function. 

Now the urls file of our app is gonna handle all the routing.
So now the default django template is removed.

--- 

We have simple http responses, these aren't dynamic, we cannot add our own html to that. There is a way but it is gonna be too messy.

So now let's add templates and for that we are creating a folder for storing all our templates and there are few ways to configure these.

Lets create a file named home.html in the templates folder.
So now we can add markups instead of simple response.
Now we need to return these inside of our views.

First thing we are gonna do is let django know about this template folder.
For that we have to go to the Templates list of our settings.py file in our main folder. In there we have a list called 'dirs' and add our templates folder using the BASE_DIR variable (This variable acutally sets our path to the base directory which here means go to the base directory and there the template folder is).

In order to reference these templates, we need to go to the views. Now we can get rid of the Http response and use render() in place of that and it takes two parameters. First one is the request object and the next one is the template name
(Remove the imported Http packge as it is not needed now.)

Now, just rendering the template isn't the best thing if we are may be adding a navigation bar. Imagine coding the navigation bar in the every single template adding all the tags and the styling.
So here we are gonna use the template inheritance and we can also include section of templates inside of other templates.
So we are gonna create a file just to contain the navbar and create an a tag inside of that and this is gonna be a link to the homepage like a logo such that whenever we click on the logo, we will be sent to the home page.

So now this code should be seen on every single page. So we have to go to the home.html file and add a template tag like ' {% include 'navbar.html' %} '. 

Now what we could do is we could create a main.html file and this is gonna allow us to create a wrapper around our templates. By default our will have different styles, themes. So we want  to include one style tag into our main theme of our website and we want it to simply encapsulate all the templates in our project.

Now get the html boiler plate and in the body section we have to add tempalates. So it is gonna tell our website where to add all these child templates when we wrap another template in our website.
Create a block for content. So in our homepage we have our main page and all the homepage content will be in here.

So instead of adding the navbar file in every template, we can now just add this in our main.html file. 
Now we have our main.html file and now we are gonna extend this in our home.html file like ' {% extends 'main.html' %} '.
Now in order to see our home content, we can now add these content tags in our home.html to let that know where our content is and now not much is gonna change we are still gonna see our navigation bar but it is no longer present in our home.html file.
Now extend main.html to room.html also wrap it with content files as we have done in the home.html file.

So that is all about including and extending the main template. Now let's pass in some data into our templates.

Let's go to views.py and create a variable named rooms which is gonna be a python list and we are gonna have some rooms which are dictionaries and represented like objects. Each room will have an id and name of that room.
Now as we have created the list, we want to render this out in our home.html template. At this point what we could do is we can pass this rooms list as a parameter in the home view as a dictionary which means it has a key value pair, like this :
                             {'rooms': rooms}   where the key specifies how we want to address this in the template and value specifies what we are passing in, which is the rooms list here.
Now we have the access of the rooms list in our template. So now we have to go to the home.html and render this list out.

OR we can save this in a variable and pass that variable just like,
             context = {'rooms': rooms}

So in that, let's create a div for the main page and inside of that create a div again which renders out all the items here. In there create a for loop using the template just like,
                      {% for room in rooms %}

                      {% endfor %}
So the difference between regular python and this templating engine is that, we have to close our room insted of just writing the syntax. So we have to close our for loop and if statements.
In each iteration we have to pass an h5 tag so we have to create a div for that.
We want to print like,  1 -- Let's learn python, for all the id's.

We know that variables can be passed in with two curly braces. So we will do like, 
                      {{room.id}} -- {{room.name}} 
So we are accessing the key value pairs from the dictionary using the object of that list.

In the views.py, we can also use the if else statements. For eg, the age, If the age is less than this, render this, otherwise render this.

-----

So we created templates folder to store all the templates we are gonna be using in our app. In the future, we will have different apps which handles different parts of our website. So we can create a templates folder which will be specific to our app.
So create a templates folder inside our base app and the weird thing about this is that django requires us to create another folder inside our templates folder which have to be named whatever your app's name is ( in our case base).
Now we have to shift our home and room files here because these are specific to our app.
So in order to actually work with this new template, we just have to specify our app now in the views.py just like,
                                 'base/home.html'           which was previously like      'home.html'
Do the same for room also.
So now all our apps templates are in the apps directory and our main templates are in the root folder.

Dynamic URL routing
So how do we get a specific object of a single room here. (eg, Click on a room and see the info about that)
So room does not have any way of that.
So the way we are gonna do this is by changing the urls.py.
We can pass a dynamic value for that (use angluar brackets <>). In that we are goona pass a string str and any value name pk for primary key.
                                    'room/<str:pk>/'
This str could be an int or slug etc based on what you are passing.

So we have to pass this pk as a parameter in the room method of the views.py.
So now we have access to whatever is inside of that parameter.

Now we are gonna wrap the room.name in the home.html file with the a tags to make them clickable and the href will be "/room/{{room.id}}" to show the details of room name as per the room id.
To actually get the value of the id, later on we are gonna use the pk to create the database but now we are using the list 
Now write the logic in the room method,
  Firstly we are gonna set the room to none and we are gonna loop through the rooms value. So whatever id matched to the pk, set that to room then we can set a context dictionary and set that context as the third parameter.
               room = none
               for i in rooms:
                   if i['id'] == int(pk):
                       room = i
               context = {'room': room}

So now in the room template we can just pass in the value. We can change that to
                 {{ room.name}}

So now whenever we click on the a tag that we have created, it will redirect it according to the id and show the name of the room there.

Now let's see how to get dynamic values from our templates
So in the url's there is a reason why we have given names to that, let's say at some point we want to change the url path, So we have to do is we have to go to every single tempate or wherever we are using it and then update all these values. It can be very annoying. So what we can do is we can change the value to whatever we want, but we can still access this url by its name
Let's go into home.html and instead to writing the path in the href we can change it with the url tag which is the built in tag inside the django templating engine just like
                 " {% url 'room' room.id %} "       inside the quotes there is the url name and the room.id is the dynamic value 
It will create the url like /room/2/,  where 2 is the room id.

So now if we want to change the url path, we do not want to change it everywhere. So it is much faster than that.

----------------

Now we are gonna set up the real database which is gonna be in our sqlite database and we want to actually query data from the database. So there will not be any need of using the rooms list anymore.

In the terminal we can see 18 unapplied migrations. Inside our settings.py, we have different apps and a lot of these apps have database sections. So basically we have a database prepped so we have a couple of tables which are ready to be migrated like django builds out a user table for us, for authentication they have built a table to store session ids. So django creates these migrations and these are basically sql commands and are ready to be executed. So they are ready to be activated but are not triggered yet. Once I run these migrations, these commands are gonna be activated and these are gonna build out all these tables which are inside the apps list (i.e, sessions, admin etc.) So we do not even have to configure the tables, django is really good at setting these up for us and making this easy. Now we are still gonna create our tables but these are the default ones that django gives us.

So stop the server and run 'python manage.py migrate'. Now these migrations are applied and basically that built out the database for us.
Now if we run our server again we are not gonna see the unapplied migations.

Now go to our app that is base and open the models.py file. This is the file where we are gonna create our database tables. 
So what we are gonna do in here is, we are gonna create python classes. The class that we are gonna create is gonna represent the database tables. The name of the table is represented by the name of the class and every single attribute in the class is gonna represent the column. So every single time we create a new row in the table, that is going to be the instance of the class.
              Class Name -> Table Name
              Attributes -> Column Name
This is called a model of a table that is why they are called models.

So the first table that we are gonna create is the table for the room which is like,
             class Room(models.Model):
                 name = models.CharField(max_length = 200)
                 description = models.TextField(null = True, blank = True)
                 updated = models.DateTimeField(auto_now = True)
                 created = models.DateTimeField(auto_now_add = True)

Models by default have an id generated which starts with 1. We can also specify the id if we want.

CharField has max_length of 255 characters while TextField can hold more than 255 characters. Use TextField when you have a large string as input.
By default, the null is set to false but here we set it to true because if it is false this means that the database cannot have an instance of this model here without having something in it. So it can be blank. So we set null to true which means that it can be blank and the next parameter is the blank which means that whenever we run the save method like we submit a forum that form can be empty.
                 blank -> For the save in the forms.
                 null -> For database.
This means that description can be left empty but name cannot because null is false by default.
Updated is gonna take a snapshot anytime this instance was updated. auto_now is set to true which means that every time the save method is called go ahead and save the timestamp automatically.

auto_now saves the timestamp everytime we save and auto_now_add only saves once when when that is first created.

We have also created a self representation of this

So the first thing after creating a model to the database is the migration. So what it is gonna do essentially is it is gonna craete a file which have a list of sql commands and how to execute this and add it to the database.

We have already executed the built-in migrations, now we are gonna execute this new migration like
             python manage.py makemigrations
So now we can see a new file in the migrations folder of the base app.
So once we make a migration and we can make a new miigration using the migrate command and this will go into the latest migration and it will execute those and we can see these migrations being applied.
Now this table is included to the database.

Let's say we want to view this, because we are not adding any third party packages to work with our sqlite database, we are gonna use the built in django admin panel with the /admin url.
In the admin panel, django already has a built-in authentication for us and in order to log in, we need a user and this user need to have admin level permission.

So we can generate the user from the command panel. For this, run
             python manage.py createsuperuser
and it will ask for the username, email and passwork for the superuser that we are creating.


So now this user is added to the database
Now if I log in to the panel, I can actually work with the database

We added in the room table here but we cannot see it in the panel. To actually see this, we need to go to the admin.py in our base app first import the room model like
         from .models import Room
Now we have to register this model with the admin panel. By this we are actually saying to the admin panel that we want to view and work with item into the built-in admin panel. For this, we have to do,
        admin.site.register(Room)

Now we can see the Room into the admin panel.
We can add rooms from there also. Now I have added two items inside of that room table. Now as we have added these we can work with the CRUD operations, render this out inside out list and view the  details.
We have added the rooms to the database but now we want to see this on the page.
In the views.py file  firstly we will import the model that we want to query (i.e, Room here)

There is something called as MODEL MANAGER.
This is how we can make queries to the database. 
            
             queryset = ModelName.objects.all()                    where, queryset = Variable that holds response
                                                                          objects  = Model objects attribute
                                                                          all      = method  ( some other methods are .get(), .filter(), .exclude() ) 
                                                                          ModelName is the name of the model which is in our case Room

So in the home method write, 
      rooms = Room.objects.all()
This is gonna give us all the rooms in the database. This rooms will now override the rooms list that we had created.
Now this room will be passed to the database.

Now if I refresh in the browser I can see the items from the database not from the rooms list that we had created before because the list is now overridden.
NOw if I click on these, it is still gonna work because our id is same as the default model ids.

We can comment out the rooms list because it is now not needed.

Now in the room method, we can now get rid of all the loops and get the room from the room model. So we are doing
           room = Room.objects.get()

get() is gonna return one single item. We need to get this by one unique value because lets say we have two items with the same names, it is gonna throw an error because it needs to get a single objects. So we have entered by the id because id should be unique in the database.

So now whenever we click on the links on the page, it goes to the view , queries the database and gets back that single item and then it renders that.

At this point we want to add a few more models to the database. We have rooms here but each room should have a category. So we want to bring that in.

Each Room is gonna have a message so we are creating a message model and for the values for an actual message, First we want to specify a user (user that is sending the message) then we are gonna specify a room which is going to be a one to many relationship because one user can have many rooms.

In there we will do models.ForeignKey() and as an argument we are gonna give the parent which is Room and the second argument is gonna be the on_delete.
If on_delete is set to models.SET_NULL it means that, whenever the parent is deleted all the instance will be set to null but the msg will still stay in the database or if we set it to models.CASCADE it means that we are simply gonna delete all the msg in that room whenever the parent is deleted.
           room = models.ForeignKey(Room, on_delete= models.SET_NULL)

For the actual msg we are gonna set a variable named 'body' and just copy and paste updated and deleted from the Room
           body = models.TextField()                 we kept it empty because we want user to write a msg.

For the user variable django already builds in  a user model for us. So for now we are gonna start with the default user model. 
For this we are gonna import the User model and now let's set the relationship and in this case this is gonna be a one to many relationship (user can have many message but a message will only have one user) and for that we will do
         user = models.ForeignKey(User, on_delete = models.CASCADE)

Now we have to go to up of the Room and in this case the Room is gonna be a child of the Topic, we have to specify a class above it. And in that we are gonna add one attribute only which is name attribute which is going to be a character field and we are gonna specify the max_length for it and a self function returning the name.
Now we wanna specify the relationship with the room. A topic can have multiple rooms but a room will only have one topic.
So in the Room attribute, we are gonna specify a topic attribute and we are gonna connect it using to the Topic using the models.ForeignKey() like,
        Topic = models.ForeignKey(Topic, on_delete = models.SET_NULL)
Because the Topic model is placed above the Room in the code, if I shift it below, I can still access this value but now I have to wrap the Topic in a string like 
        Topic = models.ForeignKey('Topic', on_delete = models.SET_NULL)

After setting it null, it will give an issue, which says that we have to allow it to be null because when it gets removed and set to null, we need to make sure that the database will allow it.
        Topic = models.ForeignKey(Topic, on_delete = models.SET_NULL, null=True)

Now we have to create a host attribute in the Room model and set USER as the host like
        Topic = models.ForeignKey(User, on_delete = models.SET_NULL, null=True)

Now we have a relationship to our Host and the User

Now again we have to prep the migrations using 'makemigrations' command in a new terminal and a second migrations file will be created into the migrations folder and then we have to execute them using the 'migrate' command and now that is gonna add it to the database.

Now in the admin.py file, we have to register these models just like we did earlier.

[ 
  NOTE : I got an error for column not found but no error in the tutorial, tried to google it and found the solution which is
                 python manage.py migrate --run-syncdb
       This command is gonna sync the db without the migrations and now the error is gone. 
]

Now we can see the topics and rooms in the admin panel.
Let's add some topics.
Now as we have created the topics, we can now set these topics in our rooms and the host also.
Add one more user and write some messages.

As per the design, we want to render out the username and the topic, so we have to update the templates.

So in the home.html, in the div, add a span tag and to render the username, we can query the host object and render the username from that.
       <span>@{{room.host.username}}</span>
This will render out the username of the host from the database.
Later on, we will make this username clickable.

And we can also render the topic name and for that we are using the small tag.
       <small>{{room.topic.name}}</small>

Now we are done with rendering out the items.

---------------------------

Now we will take a look at the CRUD operations.

So we wanna learn how to work with a database outside of django admin panel. So in order to do this, the first thing I am gonna do is, in the app's template folder I am gonna add a form template for the room and this is gonna update and create a room. So one template for two different views.

So the first thing we are gonna do is extend the main template.
           {% extends 'main.html' %}
and we are gonna wrap all the content

In the block, create a div and in that create a form which has a method POST for creating and updating and there will be an action but if there is no action it is gonna send it to the current URL that we are at. So I can send it to a specific URL.
Inside of every form in the django, for using this template engine we need to add a csrf_token (CSRF = Cross site request forgery). This token will be sent on every form submission. So when we are sending POST request in django, we need to pass in this token with every request just to make sure that there is no malicious attempts. This will help us from cross site forgery attacks.

We want a submit button also, so we are gonna specify that.
         <div>
            <form method = "POST" action="">
        	    {% csrf_token %}

                <input type="submit" value="Submit" />
 
            </form>
          </div>
Now we have our form, we can go to views file and create a view for this.

Creating a view for creting room and adding a URL for the same.
        def createRoom(request):
    		context = {}
    		return render(request, 'base/room_form.html', context)

OK so now we have out URl, a view which renders out a template and now let's just go and link this up.

So we want that user can create a room from the homepage so let's go ahead to that.
Before all the room let's create a link to create the room

We can create this form manually but we are using something called as model form for that (There is definitely a level of abstraction to this).

So let's go ahead and build out a model form. So a model form is a class based representation of a form.
So we are gonna create a new file inside of our base app called as forms.py and inside of this import the ModelForm

So all we do to create a modelform is we create a class. So there are two minimum values that we need here, so when we specify the metadata, we specify the model for which we want to create a form for, which is gonna be room model and we have to specify the field (this is gonna create the form based on the data/ metadata of the room model. we specified all here which means that it is gonna give us all the fields but later on we will specify the specific values that we want in a list)

		class RoomForm(ModelForm):
    			class Meta:
        			model = Room
        			fields = '__all__'


Now inside of the view, import that form and inside of CreateRoom, we are just gonna do
             form = RoomForm()
and now we can pass this in the context
             context = {'form':form}

And now we can pass this in room_form.html like
            {{form}}

Now if we refresh in the browser, we got the form.
Now we are gonna work on this and make it look a little bit better.
But for now we are using a quick shortcut which is {{form.as_p}}. It will wrap a paragraph tag around every input field that the form has.

Now we need to process this data.
To print the submitted data on the console, go to views.py file and below form just write, 
         if request.method == POST:
             print(request.POST)
It will print the data as a dictionary on the console.

We can also process this data manually like
            request.POST.get('name')        --> It will print the name.
But in our case we have the modelform which takes care of all this logic for us.
So we can do it like, 
           form = RoomForm(request.POST)            which means passing all the POST data into the form.
Then to save the form firstly we have to check if all the entries are valid or not. 
          if form.is_valid():
              form.save()
This is gonna save that model in the database.
Once this is save, we want user to be redirected to the homepage again.
So we will import a value called redirect and then below the save, we will return to home.
Now if I click on create room and submit that, we will be redirected to homepage and it will be shown as a new room on the homepage.

The next thing I wanna do is I want newer items to be rendered first.

So for this, we will go to models first and we will directly add this to the room method here. We will create a meta class and specify the ordering there and this is gonna be a list. So we will order this by created and then by updated.
              class Meta:
                   ordering = ['-updated', '-created']
If we don't write - with these, it will order it in the ascending order which means newest one will be last but writing - will invert it and now the newest one will be written last.

now let's go into updating a room. 
To update we already have a template that submits that POST form or the POST request ( in the room_form.html)

Now we need to create a new view and we are gonna call this updateRoom(). It is gonna look a lot like the createRoom() but there are a few changes. As an argument, we are passing the request but this time we are passing the primary key (pk) also with it because we want to know which item to be updated.

Firstly we are gonna get the item which is to be updated (in this case room).
              room = Room.objects.get(id=pk)
So we got the room, now we want the form same as the createRoom() but the difference is when we click to edit a room we want to actually know what room we are gonna edit.
So form = RoomForm() will give us an empty form that we can render in the context dictionary. So how do we get that data prefilled, so we can use the instance and pass in the room.
So now this form will be prefilled with this room value.

So for this we are gonna add an edit buttton on the homepage.

For this, we need a URL and we want id also, so we are adding the primary key also.
         path('update-room/<str:pk>/', views.updateRoom, name = "update-room"),

Now go the home.html page and add in an edit button in the top of the div. 
         <a href="{% url 'update-room' room.id %}">Edit</a>

Now we can see the edit button and when we click on the button, we can see the info. prefilled and we can now edit that from there but if we try to save that we can't because we need to process that info.

We can see that info. but now we need to process this. So we will now specify the method as we have specified before.
         if request.method == 'POST':
              form =  RoomForm(request.POST, instance=room)
              if form.is_valid():
                  form.save()
                  return redirect('home')

this instance parameter is used to tell it which room to edit. If we don't specify this, it is just gonna add a new room instead of updating.

We are done with this, now we gonna add delete method.
We are creating a new method inside of our tempates/base folder just to handle deleting (delete.html). This is gonna be a dynamic template meaning that it will be used for every deleting process when we add more functionalities later.
We are gonna make it pretty generic. 
In this, we will also give a confirmation msg to the user to confirm the deleting process and we are gonna add an obj template which changes which means that object can be msg, comment etc. Then we will add an input button to submit and the value will be confirm and we can also add a button for going back and in this case we want to send user back to the previour page not any specific page and for this href will be.
           href = "{{request.META.HTTP_REFERER}}"            --> This is gonna send the user to where they came from.

Now we have created the tempalate, we can now add the view.
and as a context we will pass the obj which means that room will be called as the obj in the template. In this, we will obviously not save as we were doing previously, we will simply use delete() to delete the room from the database.

Now we have defined the delete functionality also.

We are done with CRUD.

We we want to build some search functionality and add a side bar for quick search also.

Now firstly we are gonna add some styling here and it is gonna be very serious.
Now we will go the home.html and firstly we will make sure that the entire page is wrapped in a div and we are give this div a class called home-container. Inside of this div we will create another div for the side bar which says browse topics (h3 tag).
Now we will create another div and wrap all the rooms in that.

Now we have one container around everything, one for the topics and another one for the list of rooms.

If we refresh it now, we can see that they all are in line, so now we have to create a layout for them.

Now we will go ahead and add some styling right here.
          <style>
              .home-container{
        		display: grid;
        		grid-template-columns: 1fr 3fr;                   This means that there will be two columns as we have 2 col and right one will be wider.
    		  }
	    </style>

After refreshing, we can see two columns now.
Now we want to list out all the topics in the browse topics column.

For this, we will go to the views and make a quick query about the topics and for that we have to import the topics first.
For now, we are gonna list out everything but if we add thousands of topics into our website, we have to filter them out may be. 
           topics = Topic.objects.all()
We will now throw this into the context dictionary.
           'topics':topics
Now we have all out topics and we want to render them out into the home page.
For this, we have to loop through all the topics. In the href, we will send the user back to the homepage and then we will pass in the query.
So what's gonna happen here is we are going the home page when we click in the side bar. So when we click it, it is gonna send the user to the home page and then we will thorow in the topic name.
           {% for topic in topics %}
              <div>
                  <a href="{% url 'home'%}?q={{topic.name}}">{{topic.name}}</a>
              </div>
	      {% endfor %}

Now if we click on that, it is gonna added to the parameter and we can now get this value inside of the view and filter down some data using that.
Now as we have that, we wanna make sure that we can also go to all the topics. For this we are creating another div.
		<div>
               <a href="{% url 'home' %}">All Topics</a>
            </div>

Now in the view for the actual functionality, we can use the filter() method instead of all() but if we do not pass any parameter in the filter(), it is gonna work same as the all().
Now we will create a variable to get the q (q is query which we have just done in the for loop), q is gonna be whatever we pass in the URL. 
So as a parameter, what we can do is, we can go to topics ( models -> topic)  and then I can query upwards to the parent using the __. 
        q = request.GET.get('q')
        rooms = Room.objects.filter(topic__name = q)

Now on the first search, we will have an issue, which is because we do not have any parameters in the URL on the first search. But if we click on the topics, it will do the work.

To solve this, we need to create some kind of condition here. So the first thing is, we are gonna use an inline if statement and we will check if the request method has something and instead of setting the value directly in the parameter, we are gonna use the 'icontains', which means that, our parameter is gonna work only if we have something in the q, otherwise it will work as all().
So this means that, if we do not have anything in the URL, filter() will not work and it will now act as all().

Now if I want to query for the javascript topic but in the query, i only write the jav not the full javascript, it will still work.

Now we do not want user to search from the query in the URL that's why we will add the search bar.
We want the search bar to be dynamic because we are giving the functionality that user can search for the topic, writer etc.

So in the navbar, we can create a form for the GET method
         <form method = "GET" action="{% url 'home' %}">
             <input type="text" name="q" placeholder="Search Rooms">
         </form>

We are specifying the name as q because we want it to take the room and push it into the URL.

Let's see how we can make this dynamic. By now, we are searching by the room name only
For this, in the filter method,  we need to add the parameters but for that we need AND or OR operations to be applied. For that django gives us the qlookup method which gives us the functionaloty to use all these AND or OR operations
               rooms = Room.objects.filter(
        		Q(topic__name__icontains = q) |
        		Q(name__icontains = q) |
        		Q(description__icontains = q)
    		   )
Now we can search using three parameters but firstly we have to import qlookup which can be imported by the name Q
       from django.db.models import Q

Now we want to show the total no. of rooms found. So in the home.html we will just add
          <h5>{{room_count}} rooms available</h5>
Now we have to add this in the view
         room_count = room.count()


Now we want to talk about the authentication.
At this point, we are gonna build a user login form, user registration and user logout functionality.

So by default, django has session based authentication and how this works is the same as we have in this django admin panel. So when we go to this django admin panel and provide our credentials, this gets sent to the backend and in the backend there is a database table called sessions here. So in the settings.py -> installed apps, we can see sessions here and I you go and use something like pgadmin and postgres, you will be able to see this table.
So when we log in, this is sent to backend and a token is created and this stores information about the user. So once that user is authenticated, we now know when this user logged in, who this user is and all this info. about them.
When we request for a particular page, we check using the session id that if this user is allowed to enter this page or not ? 
So django has its own authentication panel, but we do not want users to use that, so we are gonna built our own authentication.

So let's go ahead and start this out by building out a template called as login_register.html. So we are gonna have one single form for registration, login and that page will also change according to what page the user is on whether it is login or user registration.

In there, create a template for the block and then create a div inside of that to wrap the entire website and then create a form for the login. Now django does have a built in login form, there are different ways of doing it and they also have a built in registration form. But we are gonna use our own login form. It is gonna have two fields, a username and a password. Later on, we will talk about doing this with an email instead of a username and then just we are gonna submit it.
In the form, we will add a csrf_token. For the input value, we will tell the user to log in. There are two more input fields, one for the login and other one for the password.

           <div>
               <form method = "POST" action="">
                   {% csrf_token %}
        
                   <label>Username :</label>
                   <input type="text" name="username" placeholder="Enter your username">

                   <label>Password :</label>
                   <input type="password" name="password" placeholder="Enter password">

                   <input type="submit" value= "Login">
               </form>
            </div>

Now we have our simple form.
Now we are creating a view for this login page.
          def loginPage(request):
              context = {}
              return render(request, 'base/login_register.html', context)        
 We will fill the context dictionary later.
Now we need a URL.
            path('login/', views.loginPage, name = "login"),

At this point we are gonna render this link into the navbar.

So we have the form, now we want to be able to login a user. At this point when we send this information, we need to extract these values. Earlier on, we used a modelForm() for this and that kinda took care of everything here. So instead of  having that done manually and having that user login form that is already built in, we are gonna do all of this by hand.

So firstly in the loginPage method, we are gonna check the method and then we are gonna get the username and the password from the frontend. Once we get those, we wanna make sure that this user exist. So we are gonna use a try catch block for that.

For the user, we have to import the User first and then check like
             user = User.objects.get(username = username)
In this it will check the users in the database that this username enteres matches with the one in the database.

and now we will add the except and we will use something like flash messages.
For this, as always we have to import this
         from django.contrib import messages
and then throw an error message that the user is not found.

          if request.method == 'POST':
              username = request.POST.get('username')
              password = request.POST.get('password')

              try:
                user = User.objects.get(username = username)
              except:
                messages.error(request, 'User does not exist.')


And to show that message in the browser, we have to output this flash message. For this, we have to paste this into the main template underneath the navbar which means that if we have flash messages anywhere, it will appear.

         {% if messages %}
           <ul class="messages">
      
              {% for message in messages %}
              <li>{{ message }}</li>
              {% endfor %}
    
           </ul>
          {% endif %}

So now if we enter a wrong username, it will show up a flash message and if I refresh it will be gone.

Now we have handled what happens if a user enters a wrong user is not found. Now if user is there in the database, we have to write what will happen then.
For this, we will use the authenticate method and we have to import this.

         from django.contrib.auth import authenticate, login, logout

We have also imported the login and logout method as we will need that later.

So once we make sure that we have a user, we want to authenticate this user. We wanna make sure that the credentials which are for this user are correct.
So what authenticate deos is, either it is gonna give us an object or it is gonna return back a user object that matches these credentials.
Now we will get the user if that authenticate succeeds

Now we have to check if the user is not None (which means that we got the user) and if it is not None, we have to login the user using the login() method, and what login is gonna do is it is gonna add in that session in that database and the user will be officially logged in. Once logged in, redirect the user back to the homepage. Else we will flash an error.

          if user is not None:
             login(request, user)
             return redirect('home')
          else:
             messages.error(request, 'Username or Password incorrect !! ')

Now we want to log out the user.

We can actually access the request object inside of a template. So in the navbar.html, we are gonna write a condition to chech if the user is authenticated. If it is authenticated, logout button will show up else login button will. 

           {% if request.user.is_authenticated %}
	     <a href="{% url 'logout' %}">Logout</a>
           {% else %}
           <a href="{% url 'login' %}">Login</a>
           {% endif %}

Now let's create a log out view

         def logoutUser(request):
              logout(request)
              return redirect('home')

Then we can create a URL 

         path('logout/', views.logoutUser, name = "logout"),

and add this into the navbar template.

Now at this stage, we are gonna restrict some pages based on the user or whether they are logged in or just a user browsing the website.

So firstly we will make a quick import here, we will actually add in a decorator above the view that I want to restrict. Now with class based views, we make use of mixins for this, we can also use middleware. There are several ways to restrict a user but we are gonna use simple decorators for this functionality

          from django.contrib.auth.decorators import login_required

The page that we are gonna restrict here is 'create room'
So before the createRoom view, all we have to write is

        @login_required()

At this point, once we add this decorator, if a user is not authenticated or if their session id is not in the browser , they will be simply redirected. So inside of this we have to write, where to redirect.
     
       @login_required(login_url = '/login')

And we have also added this to the updateRoom and deleteRoom.

Now if I know somebody's user credentials, I can just login and I will be allowed to go ahead and update the room, so we want to restrict the user.
For this, we are gonna write a condition in the updateRoom and in that we want to return some kind of Httpresponse and for that we have to import that obivoulsy.
 
      if request.user != room.host:
          return Httpresponse('You are not authenticated for this')

Now if someone tries to update some other user's room, he/she will not be allowed.
We will add this check for delete also.

Now at this point, we want to hide the button for any user who is not the owner.
So in the home.html, we will wrap the update-room and delete-room button in an if condition so that only the real owner can see those.

     {% if request.user == room.host %}
 
     {% endif %}

Now If I go to the login url ( I am still logged in ), I can access that but we do not want an already logged in user to login again. So we will do

          if request.user.is_authenticated:
              return redirect('home')


Now let's go ahead and move to registration.
When we are logged out and in the login page, there we want the register button.

In the login_register.html, we will create another div for the registration

    <div>
      <form method = "POST" action="">
         {% csrf_token %}
        
        
         <input type="submit" value= "Register">
       </form>
     </div>

Now after this, we can see both the buttons on the page. We will also solve that.

So what we can do is, in the loginPage view, we are just gonna pass the page name

   page = 'login'

and we will also throw this into the login dictionary.

Then under the logout page, we are gonna create a register page.

     def registerPage(request):
    	  page = 'register'
        return render(request, 'base/login_register.html')

Now make sure to create a URL for this.

In the template, we are gonna point to the register here, if the user is not already registered.
So in the login div, we will ask a question and then add a link to point to the register and then do the same thing for the login the register div.
This is the reason why we have added the page name.

In this case, if the page is 'login' then we will render out the login page and if it is not , we will login the register page.
So we will add the if else conditions.

Now django has a user creation form which already make it a lot easy for us

So we will make an import and add this in.
      
       from django.contrib.auth.forms import UserCreationForm

We are gonna customize this form but now we are gonna work with the default.
In the register view, we will pass this and save it in a variable and then pass this in as the context dictionary.

I think we don't need the page name for the register because we have given the register template in the else condition.

Now we have to render this form in the register template.

    {{ form.as_p }}

Now if I click on the register button, I will get an entire register page.

Now we need to process this form.
In the register view, 

In the is_valid statement, we are commiting it to false because we want to access the user that was created, meaning if the form is valid, the user is gonna created but we want to access the user right away and for this we have to commit it to false, So we can actually get that user object.

So the reason why we are doing this is , if for some reason the user has added in uppercase or capitalize their name or may be their email depending on how they are registering, we want to make sure that it will be converted to lower case permanently.
So we actually wanna be able to clean this data.
Once we have to done this, we can actually save this user.

NOTE :- We also have to add this lower method into the login method because what if the username is one way and when the user logges in, he accidently capitalizes the username

So once the user is registered, we want the user to log in and then we can now redirect the user to the home page.

Now in a case where something does not go correct, for that we have create an else condition also.
And in that condition, we are just gonna flash an error message.

     if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            user = form.save(commit = False)
            user.username = user.username.lower()
            user.save()
            login(request, user)
            return redirect('home')
        else:
            messages.error(request, "An error occurred !!")

Now we want to output this error, you can add different types of error handling eg. username already exists. But for now we are gonna look for any kind of error in the registration

Now as the user logges in, we can give a message on the home page which says, hello user and for this we will go to the navbar and in the if statement just write hello and then the user name.

Now we will focus on the user comment creation.

After logging in as a user, I want to now make comments and involve in the conversation.
So let's go ahead and work on the room page first (room.html)

In the box, firstly we will throw in the description.
Now we want to output the comment that are in this room.
We will create a div for the actual conversation.

Inside of the room view let's just get all the comments (i.e, get the children of this room here.)

  room_messages = room.message_set.all().order_by('-created')


order_by('-created') means it is gonna order it by descending order.

NOTE FOR THIS :- This can be tricky for the first time if you see this. We can query child object of a specific room here. If we take the parent model, in this case Room to get all the children, all we have to do is specify the model name (in this case, Message) (write in lower case). So this complete basically means, give us the set of messages that are related to this specific room. ( _set.all() is for many to one relationship )

So we have got our messages now, so we can now output those using a for loop in the room.html. 
We wanna print the username, message and the time since it was posted. 


   <div class="comment-wrapper">
   	<h3>Conversation</h3>
   	<hr>

    	{% for message in room_messages %}
    	<div>
          <small>@{{message.user}}  {{message.created|timesince}} ago</small>
          <p>{{message.body}}</p>
          <hr>
      </div>
    	{% endfor %}

    </div>

Once we have that I want to be actually create the user comment section.
For this, we will create another div and create a form inside of that.
Add a csrf token and then add an input text field to write the comment.
We will wrap this div inside of an if condition because we want only the authenticated users to comment.

	{% if request.user.is_authenticated %}
	<div class="comment-form">
    		<form method = "POST" action="">
        		{% csrf_token %}
        		<input type="text" name="body" placeholder="Write your message here ...">

    		</form>
	</div>
	{% endif %}

Now this form will send a POST request to the room view, so we will go to the room view and we have to process this here.

Here we will use the create method, previously we were using the model form which kinda auto-generates it for us. But now we have a create method (we can use save method to update something) and this mehtod does what it sounds like. It is just gonna go and create the actual message.

As we have discussed earlier, we have to set the user, room and the body. The user will be the logged in user, room is gonna be the room obviously and the body is just gonna be what we just passed in the form 
And after that we are just gonna redirect the user to the room and at this point we do have to paas in a dynamic value which is the primary key. The reason why we are using the redirect, technically I could not do this and it is still gonna be on that page, the form will be there and the page will refresh but the issue is, now this is technically a POST request and this is gonna mess up some functionality here. So we want that page to fully reload and make sure that get back on that page with a GET request.

	if request.method == 'POST':
        	message = Message.objects.create(
            	user = request.user,
            	room = room,
            	body = request.POST.get('body')
        	)
		return redirect('room', pk=room.id)

Now I also want to add in the delete functionality and the participants also (which we will show on the right side.)

So firstly we have to change the layout to actually add in some columns.
So we will go to room.html and wrap the entire room into a div to actually create a grid with the class name room-container.
At this point, we are gonna create two columns. First column will be a wrapper around all the messages and the forms (i.e, all we have written till now). Next column is gonna be for the participants, so we will create another div for that after that first div.

Now as we have created two divs for the columns and now we want the actual layout for that.
So we will create some style tags above the main div for the styling. The theme we will install will fix this.
We will now grid the display using the class of the main div. 

	<style>
    		.room-container{
        		display: grid;
        		grid-template-columns: 3fr 1fr;
    		}
	</style>

Now we can see the participants column and to add the participants, we will go into models and in the room model, we will add a field for the participants.
Now to create a many to many field, we need to use the ManyToManyField() and in that all we need to do is go ahead and go to that room and we need to specify the acutal relationship that we are setting. So we are gonna add in the user but we already have a user model connected so we need to specify a related name which just means that we can't reference a user because we already have a user up in the host ( in this case, the related name is gonna be 'participants') and then I also wanna be able to submit a form withput having to check something here, so we will just do blank=True.

	participants = models.ManyToManyField(User, related_name='participants', blank=True)

After saving this, we need to run this migration.

	python manage.py makemigrations
	pytohn manage.py migrate

Now if I go to the rooms in the admin panel, I can see the many to many fields and then use the ctrl to select the users you want to be the participants and click save.

Now to get those participants, we need to go to the room view and bring in the participants. Earlier on for the many to one relationship, we used the _set.all() but this time we have the many to many relationship, so we can simply use the all() method and obviously we can filter that out and then we will throw that into the context dictionary.

    participants = room.participants.all()

And now we can access this inside of our room.html

    <div>
        <h3>Participants</h3>
        <hr>
        
        {% for user in participants %}
            <div>
                <p>@{{user.username}}</p>
            </div>
        {% endfor %}

    </div>

Later on these usernames will be clickable so that a user can check out the profile of the participant.

So now what if someone wants to join this conversation. For example, a user commented in the room but he is not in the participants list, so we need to add this functionality

So we need to go to the views.py and actually process this. What we need to do is, once a participant is added, before redirecting we need to add the participant.

      room.participants.add(request.user)

And if at some place, we need to remove the participant we can use the remove() method.
Now if a user comments on the room, he is automatically added to the participants list.

Now we have to create a delete functionality so that users can delete their own messages.

So into the room.html in the message section, we are gonna add a link to delete the message.

      <a href="{% url 'delete-message' message.id %}">Delete</a>

Until now we don't have the delete-message url but we are gonna create that but firstly we have to create a view for that.
So for ease, we will copy paste the deleteRoom method and modify that a little bit.

	@login_required(login_url = '/login')
	def deleteMessage(request, pk):
    		message = Message.objects.get(id=pk)

    		if request.user != message.user:
        		return HttpResponse('You are not authenticated for this')
    

    		if request.method == 'POST':
        	      message.delete()
        		return redirect('room')
    		return render(request, 'base/delete.html', {'obj':message})

And now we can create a url for that.

      path('delete-message/<str:pk>/', views.deleteMessage, name = "delete-message")

We also don't want the delete link all the time, so we will make sure that the owner can see that. So we wil wrap the link into an if-else condition.

----

Now after this, we are gonna create some activity feed on the home page.
So we have to add one more column and for that firstly we need to add one more 1fr in the style tag then create create another div inside of the main div for this activity feed.

Then we will go to the home view and get all the room messages and pass that into the context dictionary.

    room_messages = Message.objects.all()

Now we will query all these messages on the homepage using the for loop.
NOw for the oredering, we can copy the meta class of the Room model and copy that to the Message model and also we can now remove the order_by() method from the room_messages in the room view.


	<div>
        <h3>Recent Activity</h3>
        <hr>
        {% for message in room_messages %}
            <div>
                <small>@{{message.user}}   {{message.created|timesince}} ago</small>
                <small>Replied to "{{message.room}}"</small>

                <p>{{message}}</p>
            </div>
        {% endfor %}
      </div>

Here to output the message, we have written only the message not the message.body because I do not want to print the whole message. But now it will follow the __str__ method that we have written for the Message model and output only first 50 characters.
So now my side bar will not be clittered up.

Now here also, we can add the delete functionality so that the user can also delete their messages from here. So just copy paste from where we have wirtten that earlier.

Now we have the topics and the activities on the homepage. But now we want to make them their own component.
Now we will build the functionality that if I browse a topic, I will see only the related activity.
So we will go to the room view and change up the messages and we will change the all() with filter() using the qlookup method
       
       room_messages = Message.objects.filter(Q(room__topic__name__icontains = q))

So we have filtered using the room name.

Now let's make some reusable components. So we will create a template names activity_component.html. Here we will make sure that we use the same activity feed inside of our profile page later on.
Let's say we go to a specific user's account, now I want to see the recent activity of that user inside of the profile page.
So I have to write the code inside of the user's account that's why we are doing it into its own component.
We are also gonna do it for the fields and the topics here.

So we will go to home.html and cut all the code from the activity div and paste that into the component (leave the div as it is).

Now inside of that div, we will simply include that component.

       {% include 'base/activity_component.html' %}

Similarly we have to create another component for topics also because we want that also in the profile page and same thing for the feed also but not the whole feed div because we do not want the room_count and all.

The reason why we have access to all these items because we are passing this data into the context dictionary and now this component is available inside of that template. So once the template sees it, it does not notice that they are different components.
So as long as they are used on the same page, it will work but if we decide to drag this into some other page without passing it into the context dictionary, it will not work.

So now as this is done, we wanna work on the user profile.
We will create another template for that named profile.html.

Firstly we will extend the main template and then create a block for the content.
Initially we will output the username and firstly after that let's create the view for that under the room and then create the URL.

Now as we have done this, we have to update this on several different places.

Firstly we will go to the feed_component and then change the span tag to the link and point to the user-profile URL and passing in the user id.

Now if I go to the browser, I can see that the usernames are now converted to link.

For the profile, we want 3 columns (topics, feed & recent activity)

Now we are gonna create 3 divs for 3 columns inside of a main div and fill them with the components.


	def userProfile(request, pk):
    		user = User.objects.get(id = pk)
    		rooms = user.room_set.all()
    		room_messages = user.message_set.all()
    		topics = Topic.objects.all()
    		context = {'user':user, 'rooms':rooms, 'room_messages':room_messages, 'topics':topics}
    		return render(request, 'base/profile.html', context)

Now let's also update the links for the username inside of the activity.

Now all this is done, we are gonna work on the statik files now.

Aside from the HTML generated by the server, web applications generally need to serve additional files such as images, JavaScript, or CSS which are necessary to render the complete web page. In Django, we refer to these files as “static files”.

Django has it's own way of configuring this.
Until now, we are writing our CSS inside of our templates and we do not want that. So now we are gonna eventually move out all the CSS out of out templates and we are gonna create our own style sheets.

So in django, we first need to create our static files, we need to let it know where to find these and then we can render these out dynamically into our templates.

So there are different types of static files and they all have their own ways of doing things. So we will create a new folder inside of our root directory called as static.
In this folder, we need to create another folder named as the styles for the CSS files and inside of that, we are gonna create a file named as the main.css.
And we have to also create another folder inside of the static named as images to store the images.

Right after creating this, we need to go to the settings.py file and let django know that we have some statik fils now.
So jump to the statik fils section in the settings.py and then

     STATIKFILES_DIRS = [
    		BASE_DIR / 'static'
     ]

Now that's officially connected. 

Let's go ahead and add some css into our css and firstlt let's change the background colour and to make this work, we will go to the main.html file and then load the static first 

	{% load static %}

and then in the CSS link, we will link it to the static that we have just loaded.

     <link rel="stylesheet" href="{% static 'styles/main.css'%}">

Now we need to specify a path for this CSS stylesheet.

Now our background colour is set and and now let's try the images. 

Get an image and paste that into the images folder and then to use the image inside of the tempalate, you can do something like

         <img src="{% static 'images/django_architecture.png' %}">

Now there are differences for user uploaded images which we will get into like when a user uploads a profile, we do have to configure the image in a different way. For this, we are gonna use something called as STATIC_ROOT in the settings, but we will use that later and we will also have to configure some URLs for that and also the static files in the production are handled a little bit differently than they are in development.

Now the next part is instatlling the theme but before that we have to fix something (check for small mistakes or any changes).
So in the create room form, at this point when we go to this, we have an option to select the host here. It was fine when we were using the basic CRUD operations but now we want this host to be automatically added based on whoever is logged in and we also don't want participants to be visible here.
So we will go to forms.py and there in the field, we have selected all but not we don't want that. So we will use the exclude method and exclude the host and the participants from there. Now we also wanna make sure that the backend knows how to process this. So we have to update a few things in the views.

In the createRoom view, we are not submitting the host. So first we have to get the room value and also commit False and now we have to set the user as the host. We have to modify it like

      room = form.save(commit = False)
      room.host = request.user
	room.save()


Now we can move to installing our theme. ( Our website looks very ugly right now. )
So we are basically gonna grab some prebuild templates, add them into our code in the django way. We will them modify some data inside of the templates.
So we will get the theme folder from the github and then we are gonna start replacing these with our templates.

Firstly we will replace our home.html with the index.html and change it's name to home.html (home.html -> home_old.html, index.htm -> home.html) 
Now in the browser, we can see that some changes but no styling till now and for that we will now add the css files.
So for that, we will put the style.css from the theme to the styles in the static folder and then in the new home.html file, we will just load the static and then link this style.css file.

Now we can see the css and with this, now our homepage started to look good.

Now we need to connect this main template to our main.css file. So we are gonna take all the content from the home.html and then paste this on the top of the main.html. Now we already have the content, I will slowly move out the content and replace it. So everything from the home.html is now in the main.html.

Firstly we will remove everything from the main tag. Now from the below old main template, we will take the navbar and put that into the new template underneath the header and we will also take the opening the closing block tag and now we will also take the flash message and put that here from the below template. Now we can get rid of all the old template.

Now we will go to home and because we have the main theme wrapping our homepage, we now no longer need the head tag and the header. We have our theme styled inside our main.html. Now we will extend the main template in the home.html and now we will wrap this whole main tag with the block tag.

Now in the browser, we can see our old navbar but we will change that now.

Now from the main.html, we will take the header tag and then paste this inside of the navbar.html above the original content and then just delete it from the main.html.
So now in the nabar.html, we have the logo and we can remove that ( we have that in the homepage. ) and now below that, we have a form which sends us to the home page as a GET method and now let's update this form inside of the theme. So at the top, we will link the a tag to the home and then there is a form also and we will firstly set the method to GET and set the action to home. For the search field (input tag), we will set the name to q.
Now we have set all the things and now we can remove the actual form from the below.

Now we can see a drop down menu on the right side but it is not working, we need some javascript for that.
So in the static folder, we will add another folder for the javascipt and from the theme folder, we will drag the script file.
Now in order to make that work, we need to add that into our main.html file.

Now in wanna update the user. We want the currently logged in user to be shown there.
So in the header class div in the navbar, we will just set the user to the requested user. Now we wil wrap this inside of the if statement and in the else, we will send the user to the login page.
And we will also update the logout button in the dropdown menu section to make that work ( just link it to the logout page. )

So there is an icon that we wanna add and the logo also we wanna add.

Now from the assets folder from the theme folder, just drag all the items to the images folder.
Now let's go and update that. Update the logo and the avatar.

Now next, we will go to the home.html. So in here, the first thing that I wanna do is , I want to get the topics here.

THIS IS SOMEHOW COMPLEX TO WRITE WHAT WE ARE CODING BUT REFER TO 4:03:00 UP TO 5:12:00 TO GET A CLEAR EXPLANATION.
(VIDEO LINK :- https://www.youtube.com/watch?v=PtQiiknWUcI)

 Here the main thing to notice is, we have all the static data in the template and we have to make them static as per old templates that we have made.

------------

After this theme applying process, let's just give user the ability to edit their account.
We don't even have this page here, so firstly we have to build that.

So for this, we will move the edit_user.html from theme folder to templates and then change the name to update-user.html

Now we need to create a view for that and also create a url for that obviously.
Now we will link this to the navbar. So in the dropdown-menu div, let's change the link to the update-user and then we have to style that.

For this, open the update-user tempalate. Delete all the things till the header, extend the main and wrap this inside of a block.
Next update some href's in the tempalate to make them work.
In the profile.html, wrap the edit user section in an if condition, so that only the right user can update the room and change the url to update-user.

So now if I am in my own room, I can edit that, but now the other's room.
In the update-user.html, remove all the room values except only one and leave form_action.
So we are gonna use a model form for these.

So go to forms.html, import the User first and we will create a model form base around this User. In the model field instead of specifying all the User because the user model has a lot of fields. There are password, superuser, etc. So for now, we are just specifying the username and the email.

	class UserForm(ModelForm):
          class Meta:
        	 model = ['username', 'email']

Later on, we will add more in this.

So inside of the view, we need to import this and render this in the updateUser view and the instance will be the requested user and pass this inside of the context dictionary.

So now in the update-user.html, let's access this and create a for loop for that.
Below the csrf_token, create a for loop and output every single form.

So now we will only see the username and the email section in the edit user. So we want to be able to process this. So in the updateUser view, we will just create an if condition and save the form if it is valid.

    @login_required(login_url = 'login')
    def updateUser(request):
    	 user = request.user
    	 form = UserForm(instance = user)

    	 if request.method == 'POST':
     	     form = UserForm(request.POST, instance = user)
           if form.is_valid():
              form.save()
              return redirect('user-profile', pk = user.id)

     	 return render(request, 'base/update-user.html', {'form':form})

So now we can edit the user profile and it will be updates when we submit.